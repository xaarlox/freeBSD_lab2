# freeBSD_lab2
## Завдання №1
Напишіть програму для визначення моменту, коли time_t закінчиться. Дослідіть, які зміни відбуваються в залежності від 32-бітної та 64-бітної архітектури. Дослідіть сегменти виконуваного файлу.
## Реалізація завдання
- Виводиться розмір типу `time_t` в байтах за допомогою функції `sizeof(time_t)`.
- Перевірка, чи є `time_t` підписаним чи беззнаковим, порівнюючи значення `(time_t)-1` з 0.
- Розрахунок максимално можливого значення `time_t`.
- Пошук максимально допустимого значення `time_t`. Це відбувається в циклі. Програма заменшує значення `max_time` до тих пір, поки функція `ctime(&max_time)` не поверне значення, відмінне від NULL.
- Виведення максимально допустимого значення та відповідної дати.
## Компіляція та виконання програми
### 32-бітна система:
![image](https://github.com/user-attachments/assets/f7a9707c-e251-4e35-8713-890d44b27165)

### 64-бітна система:
![image](https://github.com/user-attachments/assets/18f040c2-9fc7-4b63-8e7a-4b70799efb52)

Отже, як ми можемо бачити з виконання програми різниця полягає в наступному:
+ асвіф
## Дослідження сегментів виконуваного файлу
[`nm file`](http://silmor.de/qtstuff.proginfo.php) - ця команда виводить символи всередині об'єктного файлу або статистичної бібліотеки. Вона також може показувати символи в динамічних бібліотеках та виконуваних файлах, якщо вони не були очищені. Результат виконання команди:

![image](https://github.com/user-attachments/assets/4222f64f-e53c-4fb6-89af-ed5eccca4b7a)

[`objdump -x file`](http://silmor.de/qtstuff.proginfo.php) - виводить вміст об'єктного файлу, бібліотеки або виконуваного файлу, включаючи динамічні залежності, імпортовані та експортовані імена символів. Результати виконання команди:

![image](https://github.com/user-attachments/assets/8b0f46a7-9ec2-4f01-be2c-ce4fb8aaeb40)

Примітка: Оскільки виконання команди `objdump -x file` тягне за собою багато інформації (у тому числі скрінів), було вирішено прикріпити тільки інформацію про `Program Header`.

## Завдання №2
Розгляньте сегменти у виконуваному файлі.
1. Скомпілюйте програму `hello world`, запустіть `ls -l` для виконуваного файлу, щоб отримати його загальний розмір, і запустіть `size`, щоб отримати розміри сегментів всередині нього.
2. Додайте оголошення глобального масиву із `1000 int`, перекомпілюйте й повторіть вимірювання. Зверніть увагу на відмінності.
3. Тепер додайте початкове значення в оголошення масиву (пам’ятайте, що C не змушує вас вказувати значення для кожного елемента масиву в ініціалізаторі). Це перемістить масив із сегмента `BSS` у сегмент даних. Повторіть вимірювання. Зверніть увагу на різницю.
4. Тепер додайте оголошення великого масиву в локальну функцію. Оголосіть другий великий локальний масив з ініціалізатором. Повторіть вимірювання. Дані розташовуються всередині функцій, залишаючись у виконуваному файлі? Яка різниця, якщо масив ініціалізований чи ні?
5. Які зміни відбуваються з розмірами файлів і сегментів, якщо ви компілюєте для налагодження? Для максимальної оптимізації?
## Реалізація, компіляція та виконання завдання
1. ![image](https://github.com/user-attachments/assets/2cf83e6d-473a-470c-b80a-6bb0072c6f1a)
2. ![image](https://github.com/user-attachments/assets/960a27f1-fec1-4bd0-8587-4be9e0305ad0)
3. ![image](https://github.com/user-attachments/assets/dccbff51-6a21-4601-a3b6-13174fd90129)
4. ![image](https://github.com/user-attachments/assets/9074d4bc-1cbb-457f-bf6a-a1e36e669c0b)
5. ![image](https://github.com/user-attachments/assets/072c8f5b-85cc-417b-8690-be387ae7675c)
## Висновки до завдання №2
